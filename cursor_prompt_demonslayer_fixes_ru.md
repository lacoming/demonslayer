Ты — senior fullstack engineer. В проекте demonslayer (Next.js 14 App Router + TS + Tailwind + shadcn/ui + Prisma + SQLite) нужно интегрировать AI через OpenRouter для режимов “Спарринг” и “Пробное интервью”.

Важные условия:
- UI на русском.
- Никаких ключей на клиенте. OpenRouter ключ только на сервере.
- Не коммитить .env.
- Использовать OPENROUTER_API_KEY, OPENROUTER_MODEL, AI_MODE из .env (уже настроены).

========================================
A) ИНТЕГРАЦИЯ OPENROUTER (server-only)
========================================
1) Добавь серверный клиент OpenRouter в `lib/openrouter.ts`:
- endpoint: https://openrouter.ai/api/v1/chat/completions
- headers:
  - Authorization: Bearer ${OPENROUTER_API_KEY}
  - Content-Type: application/json
  - HTTP-Referer: http://localhost:3000
  - X-Title: Demon Slayer Career Sprint
- Реализуй функцию:
  `chatCompletion({ messages, model, maxTokens, temperature }): Promise<string>`
  которая возвращает текст `choices[0].message.content`.
- Добавь защиту: если ключа нет — бросать ошибку с понятным текстом.

2) Создай API роуты:
- `POST /api/ai/sparring/evaluate`
- `POST /api/ai/interview/turn`
Все вызовы AI — только через эти роуты.

3) Ограничения расходов:
- default: max_tokens 450, temperature 0.3
- в ответах строго JSON (чтобы не было “воды”)
- если OpenRouter вернул ошибку/429 — показать toast “Лимит/ошибка AI, попробуйте позже”.

========================================
B) РАНГИ СЛОЖНОСТИ СПАРРИНГА + ГЕЙТИНГ
========================================
1) Введи 11 уровней сложности (и ранги) строго в этом порядке:
1. Мизуното (1 балл за засчитанный ответ)
2. Мизуноэ (2)
3. Каното (3)
4. Каноэ (4)
5. Цутиното (5)
6. Цутиноэ (6)
7. Хиното (7)
8. Хиноэ (8)
9. Киното (9)
10. Киноэ (10)
11. Хашира (11)

2) Спарринг имеет свой “общий зачёт” и “текущий доступный уровень”.
- Добавь в БД сущность прогресса спарринга (Prisma):
  `SparringProgress`
    - userId (unique)
    - totalPoints (int) — сумма баллов за засчитанные ответы
    - unlockedRankIndex (int) — 1..11
    - markPoints (int) — прогресс “метки” (может быть равен totalPoints)
    - createdAt, updatedAt
- Добавь `SparringAttempt`
    - id
    - userId
    - date (YYYY-MM-DD)
    - rankIndex (int 1..11)
    - question (text)
    - userAnswer (text)
    - aiScore (float)
    - passed (boolean)
    - pointsAwarded (int)
    - feedbackJson (text)
    - createdAt

3) Правило начисления:
- Ответ оценивается по 10-балльной шкале.
- Если score >= 7.5 → PASSED=true → начислить pointsAwarded = rankIndex (Мизуното=1 … Хашира=11).
- Если score < 7.5 → PASSED=false → pointsAwarded=0.
- После оценки НЕТ кнопки “повторить ответ сейчас”. Есть только:
  - “Показать разбор” (если ещё не показан)
  - “Следующий вопрос”

4) Гейтинг уровня (нельзя выбрать уровень выше текущего в общем зачёте):
- Уровень unlock считаем по totalPoints:
  - каждые 1000 очков открывают следующий ранг:
    unlockedRankIndex = min(11, 1 + floor(totalPoints / 1000))
  - пример: 0–999 → открыт Мизуното
           1000–1999 → открыт Мизуноэ
           ...
- Пользователь может выбрать любой уровень <= unlockedRankIndex.

========================================
C) “МЕТКА ОХОТНИКА” — ОТДЕЛЬНАЯ ШКАЛА
========================================
1) Добавь в UI отдельную шкалу “Метка охотника” (в Спарринге и/или в TopBar):
- Метка проявляется полностью при достижении 1000 “очков метки”.
- Для MVP пусть markPoints = totalPoints.
- Отображение:
  - progress = (markPoints % 1000) / 1000
  - текст: “Метка: 340 / 1000”
  - после достижения кратных 1000:
    - показывать toast “Метка усилилась: ступень X”
    - ступень = 1 + floor(markPoints/1000) (можно ограничить 11)

========================================
D) КОНТЕНТ ВОПРОСОВ И ПОДБОР ПО УРОВНЮ
========================================
1) Добавь файл `content/sparring_bank.json` (или расширь существующий questions.json):
- Каждый вопрос должен иметь:
  - id
  - cycleCode (1..11)
  - category (JS/Browser/React/TS/Arch/etc)
  - minRankIndex (1..11) — с какого уровня этот вопрос допустим
  - question (string)
  - keyPoints (string[]) — ожидания (можно пусто, если AI сам оценит)

2) Выбор вопроса:
- Пользователь выбирает уровень сложности rankIndex (<= unlocked).
- Бэкенд выбирает случайный вопрос из банка, где minRankIndex <= rankIndex и cycleCode соответствует текущему циклу пользователя.
- Если банк пуст по фильтру — fallback:
  - выбрать из текущего cycle без учета minRank
  - или выбрать из общего пула JS Core

3) Важно:
- Повтор вопроса “когда-нибудь” допустим.
- Не показывать один и тот же вопрос два раза подряд: сохраняй lastQuestionId в SparringProgress или в сессии.

========================================
E) PROMPT ДЛЯ AI: СПАРРИНГ (оценка как техлид)
========================================
Сделай отдельный файл `prompts/sparring.system.txt` и формируй messages так:
- system = содержимое файла
- user = JSON с полями:
  - rankName, rankIndex
  - cycleTitle
  - question
  - userAnswer
  - (optional) keyPointsFromBank

System prompt (вставь дословно, без лишнего):

[SPARRING_SYSTEM_PROMPT]
Ты — строгий техлид, проводящий спарринг для подготовки Middle Frontend разработчика. Оцениваешь ответ кандидата на русском языке.

Уровни сложности (ранги) и ожидания:
1) Мизуното: базовые определения, 1–2 простых примера, без путаницы в терминах.
2) Мизуноэ: базовая причина-следственность, 1 пример “что будет если…”, минимум 1 edge case.
3) Каното: уверенная модель работы (как устроено), отличает похожие понятия, умеет объяснить trade-off на простом уровне.
4) Каноэ: приводит корректные примеры кода/сценарии, замечает частые ошибки, даёт ясные определения.
5) Цутиното: объясняет внутренние механики на уровне “что происходит под капотом”, называет типичные ловушки.
6) Цутиноэ: связывает тему с производительностью/UX/SSR, даёт 2–3 кейса применения, видит побочные эффекты.
7) Хиното: структурирует ответ как на собесе (определение → как работает → пример → pitfalls → вывод), уверенно отвечает на уточняющие.
8) Хиноэ: делает сравнения (A vs B), предлагает альтернативы, выбирает по контексту, ясно говорит о компромиссах.
9) Киното: инженерная глубина: ограничения, крайние случаи, диагностика багов, “как проверить”.
10) Киноэ: системное мышление: взаимосвязь с архитектурой приложения, безопасностью, тестируемостью.
11) Хашира: уровень эксперта: точность формулировок, уверенное reasoning, умеет “продавить” тему как интервьюер, но без воды.

Критерии оценки (0–10):
- Корректность (0–4)
- Полнота (0–3)
- Ясность/структура (0–2)
- Практичность (пример/кейс) (0–1)

Проходной балл: 7.5. Если ниже — баллы не начисляются. Повторить сейчас нельзя.

Твои правила:
- Не льсти.
- Без длинных лекций.
- Пиши кратко, но по делу.
- Верни СТРОГО валидный JSON, без markdown, без пояснений вокруг.

Формат ответа (строго):
{
  "score": number,
  "passed": boolean,
  "strengths": string[],
  "mistakes": string[],
  "missing": string[],
  "betterAnswer": string,
  "followUpQuestion": string
}
[/SPARRING_SYSTEM_PROMPT]

В `betterAnswer` дай компактный “идеальный ответ” на 6–10 предложений.
В `followUpQuestion` задай один уточняющий вопрос как интервьюер.

========================================
F) UI СПАРРИНГА (страница /sparring)
========================================
1) Добавь:
- селектор уровня сложности (dropdown):
  - показывает уровни <= unlockedRankIndex
  - уровни выше — disabled + tooltip “Откроется позже”
- отдельный виджет “Метка охотника” (progress + число)
- кнопка “Следующий вопрос”
- textarea “Ваш ответ”
- кнопка “Отправить на оценку” (disabled, если ответ пустой/слишком короткий, например < 40 символов)

2) После оценки:
- показать score, PASSED/НЕ ЗАСЧИТАНО
- показать strengths/mistakes/missing (в виде аккуратных списков)
- `betterAnswer` в отдельном блоке “Как лучше ответить”
- кнопка “Следующий вопрос”
- НЕ показывать кнопку “попробовать снова” для этого же вопроса

3) Сохранение:
- каждый оцененный ответ сохранять в SparringAttempt
- если passed=true:
  - увеличить totalPoints
  - пересчитать unlockedRankIndex
  - обновить markPoints
  - показать toast “+N опыта метки”

========================================
G) ПРОБНОЕ ИНТЕРВЬЮ (реализуй разумно)
========================================
Сделай “Пробное интервью” как чат-симуляцию техлида, но экономно по токенам.

MVP-формат:
- “Сессия интервью” на 15–20 минут (таймер как сейчас или проще)
- AI задаёт вопрос, пользователь отвечает, AI:
  - даёт короткий фидбек
  - задаёт 1 follow-up
  - после ответа на follow-up — ставит оценку по 10 и идёт к следующему вопросу
- За сессию 6–10 вопросов максимум.

API:
- `POST /api/ai/interview/turn` принимает:
  - mode: "start" | "answer"
  - cycleCode
  - rankIndex (используй unlockedRankIndex как сложность)
  - history: последние 6-8 сообщений (чтобы не раздувать контекст)
  - userAnswer (если mode=answer)
- Возвращает:
  - interviewerMessage (следующий вопрос/уточнение)
  - scoreDelta/lastScore (если был раунд оценки)
  - shortFeedback (если был)

Сохранение:
- Используй существующую таблицу MockRound (если есть) или добавь InterviewSession + InterviewTurn (по желанию).
- Как минимум сохраняй итоги: date, score, notes.

PROMPT ДЛЯ ИИ-ИНТЕРВЬЮЕРА:
Сделай файл `prompts/interview.system.txt`. Он должен:
- играть роль техлида
- задавать вопросы по текущему cycle и по базе (JS/Browser/React/TS)
- быть строгим, коротким
- всегда возвращать JSON.

System prompt (вставь дословно):

[INTERVIEW_SYSTEM_PROMPT]
Ты — техлид, проводящий пробное интервью Middle Frontend разработчика. Язык — русский. Стиль — строгий, деловой, без воды.

Правила:
- Задавай по одному вопросу за раз.
- После ответа кандидата задай 1 уточняющий вопрос (follow-up), если есть смысл углубить.
- Затем дай короткий фидбек и оценку 0–10 за этот мини-раунд.
- Переходи к следующему вопросу.
- Не пиши длинные объяснения. Фидбек 3–6 буллетов.

Выходной формат строго JSON:
{
  "type": "question" | "followup" | "feedback",
  "message": string,
  "score": number | null,
  "notes": string[] | null
}
[/INTERVIEW_SYSTEM_PROMPT]

========================================
H) КРАСИВОЕ ОТОБРАЖЕНИЕ ТЕОРИИ (убрать “внутренности” markdown)
========================================
На экране задания сейчас видна “сырая md-разметка”. Нужно:
- рендерить markdown как нормальный UI (заголовки, списки, жирный текст)
- без отображения служебных символов

Реализация:
1) Установи `react-markdown` + `remark-gfm`.
2) Создай компонент `components/MarkdownView.tsx`:
- принимает `content: string`
- рендерит через <ReactMarkdown remarkPlugins={[remarkGfm]}>...
- оберни в Tailwind `prose prose-invert max-w-none` (если подключена typography) или сделай свои классы.
3) В странице задания заменить вывод текста на <MarkdownView content={step.content} />

Если Tailwind Typography не установлен — установить `@tailwindcss/typography`.

========================================
I) РУССИФИКАЦИЯ
========================================
Все тексты UI на русском:
- Навигация
- Кнопки
- Подписи
- Тосты
- Заголовки
(Смешения EN/RU быть не должно.)

========================================
J) Acceptance Criteria
========================================
Готово, если:
- Sparring использует OpenRouter и выдаёт оценку + разбор в JSON-парсинге.
- Есть уровни сложности по рангам и гейтинг (нельзя выше unlocked).
- Есть отдельная шкала “Метка охотника” и она растёт от засчитанных ответов.
- Порог засчёта 7.5, без повтора “прямо сейчас”.
- Interview mode работает (MVP чат-симуляция), ответы оценены.
- Теория отображается красиво (markdown рендерится корректно, без “сырой разметки”).
- Всё на русском.

Сделай изменения аккуратно, с типизацией DTO, без any, без alert (используй toast).
