# Прототипы и [[Prototype]] в JavaScript

## Зачем это нужно

Прототипное наследование — один из ключевых механизмов JavaScript. Даже если ты редко пишешь `class`, ты постоянно сталкиваешься с прототипами, потому что:
- все “методы” массивов/строк/объектов (`map`, `slice`, `toUpperCase`) работают через прототипы
- `instanceof`, `in`, `hasOwnProperty` и многие проверки завязаны на прототипную цепочку
- понимание прототипов помогает дебажить “почему у объекта есть этот метод?”
- на собеседованиях это типичная middle-тема (особенно: `[[Prototype]]`, `__proto__`, `prototype`, прототипная цепочка)

---

## Краткое определение

**Прототип** — это объект, на который другой объект ссылается как на “родителя” для поиска свойств и методов.

У каждого объекта в JS есть скрытая ссылка **`[[Prototype]]`** (внутренний слот), которая указывает на другой объект или `null`.

Ключевая идея:
> Если свойства нет на объекте, JS ищет его по цепочке `[[Prototype]]` вверх.

---

## Как это работает (модель в голове)

### Поиск свойства (property lookup)

Когда ты читаешь `obj.someProp`, движок делает:

1) Ищет `someProp` в самом объекте `obj` (own property)  
2) Если не найдено — идёт в `obj.[[Prototype]]`  
3) Повторяет шаги, пока не найдёт свойство или пока прототип не станет `null`

Это называется **прототипная цепочка**.

---

## [[Prototype]], __proto__ и prototype — не путать

### 1) [[Prototype]]
- это **внутренний слот** (скрытое поле)
- напрямую в коде не обращаются (это не обычное свойство)

### 2) __proto__
- исторический “геттер/сеттер” для доступа к `[[Prototype]]`
- **не рекомендуется** использовать в проде (но знать надо)

```js
const obj = {};
console.log(obj.__proto__ === Object.prototype); // true
```

### 3) prototype (у функций)
`prototype` — это **обычное свойство функции-конструктора**, которое используется при `new`.

```js
function User() {}
console.log(User.prototype); // объект
```

Правило:
> `User.prototype` — это объект, который станет `[[Prototype]]` у экземпляра, созданного через `new User()`.

---

## new и прототип

```js
function User(name) {
  this.name = name;
}

User.prototype.sayHi = function () {
  return `Hi, ${this.name}`;
};

const u = new User("Alex");
u.sayHi(); // "Hi, Alex"
```

Что делает `new` (упрощённо):
1) создаёт новый объект `{}`
2) ставит ему `[[Prototype]] = User.prototype`
3) вызывает `User` с `this = новый объект`
4) возвращает новый объект (если конструктор не вернул объект явно)

---

## Object.create — ручное наследование

`Object.create(proto)` создаёт объект с `[[Prototype]]`, равным `proto`.

```js
const animal = {
  speak() { return "..." }
};

const dog = Object.create(animal);
dog.speak(); // "..."
```

---

## Shadowing: “перекрытие” свойств

Если свойство есть и в объекте, и в прототипе — побеждает “ближайшее”.

```js
const proto = { x: 1 };
const obj = Object.create(proto);

obj.x; // 1
obj.x = 10;
obj.x; // 10 (собственное свойство)
```

---

## Типовые ловушки (любят на собеседованиях)

### Ловушка 1 — методы на экземпляре vs на prototype
```js
function User() {
  this.say = function () {};
}
```
Так плохо:
- у каждой инстанции своя функция
- больше памяти

Правильнее:
```js
User.prototype.say = function () {};
```

---

### Ловушка 2 — instanceof
```js
u instanceof User
```
Работает так:
- ищет `User.prototype` в прототипной цепочке `u`

Если цепочка “сломана” — результат неожиданный.

---

### Ловушка 3 — Object.prototype pollution
Если кто-то добавит поле в `Object.prototype`, оно появится “везде” при lookup и может ломать код.

---

## Как отвечать на собеседовании

Структура ответа:

1) У каждого объекта есть `[[Prototype]]` (внутренний слот)
2) При чтении свойства идём по прототипной цепочке вверх
3) `__proto__` — доступ к `[[Prototype]]` (исторически)
4) `prototype` — свойство функции-конструктора, которое станет `[[Prototype]]` у объектов, созданных через `new`
5) Пример: `User.prototype.sayHi`, `new User()`
6) Про `instanceof`: ищет `User.prototype` в цепочке

---

## Вопросы для самопроверки

1. Что такое `[[Prototype]]` и чем он отличается от `prototype`?
2. Почему `__proto__` считается нежелательным?
3. Как работает поиск свойства по цепочке?
4. Что делает `new` пошагово?
5. Как работает `instanceof`?

---

## Связанные темы

- class (синтаксический сахар над прототипами)
- this (в конструкторах и методах)
- Object.create
- hasOwnProperty / in
