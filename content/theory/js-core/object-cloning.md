# Клонирование объектов в JavaScript: shallow vs deep

## Зачем это нужно

Клонирование объектов — критичная тема для работы со state, иммутабельностью и предсказуемостью данных.
Ошибки здесь приводят к:
- «протеканию» изменений между объектами
- багам в React/Vue (state меняется незаметно)
- трудноуловимым сайд-эффектам

На собеседованиях часто спрашивают:
- разницу между **поверхностным (shallow)** и **глубоким (deep)** копированием
- способы клонирования и их ограничения

---

## Краткие определения

**Shallow copy (поверхностная копия)** — копируются только ссылки первого уровня.  
Вложенные объекты остаются общими.

**Deep copy (глубокая копия)** — рекурсивно копируются все уровни объекта, вложенные ссылки разрываются.

Ключевая идея:
> Shallow copy безопасен только для плоских структур.

---

## Shallow copy: способы и поведение

### Object.assign

```js
const a = { x: 1, nested: { y: 2 } };
const b = Object.assign({}, a);

b.nested.y = 10;
console.log(a.nested.y); // 10 ❗
```

---

### Spread оператор

```js
const b = { ...a };
```

Поведение такое же, как у `Object.assign`.

---

### Array shallow copy

```js
const arr = [{ x: 1 }];
const copy = [...arr];

copy[0].x = 5;
console.log(arr[0].x); // 5
```

---

## Deep copy: основные подходы

### JSON.parse(JSON.stringify)

```js
const deep = JSON.parse(JSON.stringify(obj));
```

❗ Ограничения:
- теряются `undefined`, `Symbol`, `Function`
- `Date` превращается в строку
- не работает с циклическими ссылками

---

### structuredClone (современный способ)

```js
const deep = structuredClone(obj);
```

Плюсы:
- корректно копирует Date, Map, Set
- поддерживает циклические ссылки
- нативный API

Минусы:
- недоступен в старых средах

---

### Ручное глубокое копирование

Используется редко и опасно, если не учитывать все типы.

```js
function deepClone(obj) {
  if (typeof obj !== "object" || obj === null) return obj;

  const copy = Array.isArray(obj) ? [] : {};
  for (const key in obj) {
    copy[key] = deepClone(obj[key]);
  }
  return copy;
}
```

❗ Не учитывает Date, Map, Set, классы, циклы.

---

## Типовые ловушки

### Ловушка 1 — “я скопировал объект, но он всё равно меняется”
Причина: использован shallow copy, а структура вложенная.

### Ловушка 2 — JSON как “универсальный” способ
JSON-подход удобен, но **не универсален** и часто ломает данные.

---

## Когда что использовать

- **Spread / Object.assign** — для плоских объектов и быстрых копий
- **structuredClone** — лучший выбор для deep copy (если доступен)
- **JSON.parse/stringify** — только если точно знаешь ограничения

---

## Как отвечать на собеседовании

Хороший ответ:

1. Объяснить разницу shallow vs deep
2. Привести пример с вложенным объектом
3. Назвать способы:
   - spread / Object.assign
   - JSON.parse/stringify
   - structuredClone
4. Упомянуть ограничения JSON
5. Сказать, что structuredClone — предпочтительно

---

## Вопросы для самопроверки

1. Почему spread — не deep copy?
2. Что потеряется при JSON-клонировании?
3. В чём преимущество structuredClone?
4. Когда shallow copy безопасен?
5. Почему ручной deep clone опасен?

---

## Связанные темы

- Иммутабельность
- State management
- Map / Set
- Performance
