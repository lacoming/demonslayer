# Promise в JavaScript

## Зачем это нужно

Promise — базовый инструмент работы с асинхронностью в современном JS. Он нужен, чтобы:
- описывать асинхронные операции **декларативно** (не “колбэк в колбэке”)
- строить цепочки действий (`then`) и централизованно обрабатывать ошибки (`catch`)
- понимать `async/await` (это синтаксический сахар поверх Promise)
- писать предсказуемый код для запросов, SSR/CSR данных, взаимодействия с API, очередей задач

На собеседованиях Promise — обязательная тема: по ней видно, понимаешь ли ты **асинхронность, микрозадачи и распространение ошибок**.

---

## Краткое определение

**Promise** — это объект-обёртка над асинхронным результатом, который может быть:
- **pending** (ожидание),
- **fulfilled** (успех, есть значение),
- **rejected** (ошибка, есть причина).

Ключевая идея:
> Promise “представляет” значение, которое будет доступно в будущем.

---

## Как это работает (модель в голове)

### Состояния и одноразовость
Promise **переходит из pending в fulfilled/rejected один раз** и больше не меняется.

```js
const p = new Promise((resolve, reject) => {
  resolve(1);
  reject(new Error("nope")); // не сработает
});
```

### then/catch/finally — это всегда новый Promise
Каждый вызов `then/catch/finally` возвращает **новый** Promise.
Это позволяет строить цепочки и менять результат на каждом шаге.

```js
Promise.resolve(1)
  .then(x => x + 1)     // вернёт 2
  .then(x => x * 10)    // вернёт 20
  .then(console.log);
```

### Планирование выполнения
Колбэки `then/catch/finally` выполняются **асинхронно** как **микрозадачи** (microtasks):
- не во время текущего синхронного стека,
- а после его завершения, перед следующей макрозадачей.

---

## Ключевые детали и нюансы

### 1) “Возврат значения” vs “возврат Promise”
- Если из `then` вернуть **значение**, следующий `then` получит это значение.
- Если вернуть **Promise**, следующий `then` дождётся его завершения.

```js
Promise.resolve(1)
  .then(x => x + 1) // значение 2
  .then(x => Promise.resolve(x * 10)) // Promise(20)
  .then(console.log); // 20
```

### 2) Ошибки “протекают” вниз по цепочке
Ошибка, выброшенная в `then`, превращает цепочку в rejected, пока не встретится `catch`.

```js
Promise.resolve()
  .then(() => {
    throw new Error("boom");
  })
  .then(() => console.log("не выполнится"))
  .catch(err => console.log("caught:", err.message));
```

### 3) Можно ли обработать ошибку через then?
Да: `then(onFulfilled, onRejected)`.
Но на практике чаще используют `catch`, чтобы отделять успех от ошибок.

```js
Promise.reject("X").then(
  () => {},
  (err) => console.log("handled in then:", err)
);
```

### 4) finally не меняет “смысл” результата (если не бросит ошибку)
`finally` полезен для очистки (loader/spinner), но:
- не получает значение/ошибку как аргумент,
- возвращаемое значение `finally` игнорируется (кроме случая, когда оно бросает ошибку или возвращает rejected).

---

## Типовые ловушки (любят на собеседованиях)

### Ловушка 1 — порядок логов
```js
console.log("A");

Promise.resolve().then(() => console.log("B"));

console.log("C");
```
Порядок: A, C, B (B — микрозадача)

---

### Ловушка 2 — “забыли return” в then
```js
Promise.resolve()
  .then(() => {
    fetch("/api"); // нет return
  })
  .then(() => console.log("дальше пошли сразу"));
```
Без `return` цепочка **не ждёт** `fetch`.

Правильно:
```js
Promise.resolve()
  .then(() => fetch("/api"))
  .then(() => console.log("после fetch"));
```

---

### Ловушка 3 — проглатывание ошибок
```js
Promise.resolve()
  .then(() => {
    JSON.parse("{"); // бросит
  })
  .catch(() => {
    // пустой catch — ошибка “съедена”, дальше всё как будто ок
  })
  .then(() => console.log("пойдёт дальше"));
```
Так можно спрятать проблему. Лучше логировать/пробрасывать дальше.

---

## Статические методы Promise

### Promise.all
Ждёт **все**. Если хотя бы один rejected — всё rejected.

```js
await Promise.all([p1, p2, p3]);
```

### Promise.allSettled
Ждёт **все**, никогда не падает, возвращает статусы.

### Promise.race
Возвращает первый завершившийся (успех или ошибка).

### Promise.any
Возвращает первый **успешный**. Если все упали — AggregateError.

---

## Примеры кода

### Пример 1 — цепочка с трансформациями
```js
fetch("/user")
  .then(r => r.json())
  .then(user => user.id)
  .then(id => fetch(`/orders?user=${id}`))
  .then(r => r.json())
  .then(orders => console.log(orders))
  .catch(console.error);
```

### Пример 2 — параллельные запросы
```js
const [user, orders] = await Promise.all([
  fetch("/user").then(r => r.json()),
  fetch("/orders").then(r => r.json())
]);
```

### Пример 3 — fallback через any
```js
const data = await Promise.any([
  fetch("/primary").then(r => r.json()),
  fetch("/backup").then(r => r.json())
]);
```

---

## Как отвечать на собеседовании

Структура ответа:

1) Что такое Promise: объект будущего результата, 3 состояния
2) Как строятся цепочки: `then/catch/finally` → новый Promise
3) Как распространяются ошибки: throw → rejected → ловим catch
4) Связь с Event Loop: then выполняется в микрозадачах
5) Методы: `all`, `race`, `any`, `allSettled` — когда что

---

## Вопросы для самопроверки

1. Какие состояния у Promise и почему он одноразовый?
2. Чем отличается “вернуть значение” от “вернуть Promise” в `then`?
3. Можно ли обработать ошибку через `then`? В чём минусы?
4. Чем отличаются `all`, `allSettled`, `race`, `any`?
5. Почему `then` выполняется после синхронного кода?

---

## Связанные темы

- Event Loop и микрозадачи
- async/await
- AbortController
- Обработка ошибок и retry
