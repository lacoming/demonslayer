{
  "область видимости": {
    "title": "Область видимости (Scope)",
    "description": "Область программы, в которой переменная или функция доступна для использования. Определяет, где именно в коде можно обратиться к идентификатору.",
    "aliases": ["scope"]
  },

  "лексическая область видимости": {
    "title": "Лексическая область видимости",
    "description": "Правило, согласно которому область видимости переменных определяется местом объявления функции в коде, а не местом её вызова.",
    "aliases": ["lexical scope"]
  },

  "замыкание": {
    "title": "Замыкание (Closure)",
    "description": "Функция, которая имеет доступ к переменным из внешней (лексической) области видимости даже после того, как внешняя функция завершила выполнение.",
    "aliases": ["closure"]
  },

  "глобальная область видимости": {
    "title": "Глобальная область видимости",
    "description": "Область видимости, в которой находятся переменные и функции, объявленные вне любых функций или блоков. Доступна из любого места программы.",
    "aliases": []
  },

  "функциональная область видимости": {
    "title": "Функциональная область видимости",
    "description": "Область видимости, ограниченная телом функции. Переменные, объявленные внутри функции, недоступны за её пределами.",
    "aliases": []
  },

  "блочная область видимости": {
    "title": "Блочная область видимости",
    "description": "Область видимости, ограниченная блоком кода в фигурных скобках `{}`. Поддерживается переменными, объявленными с помощью `let` и `const`.",
    "aliases": ["block scope"]
  },

  "var": {
    "title": "var",
    "description": "Ключевое слово для объявления переменных в JavaScript со старым поведением: без блочной области видимости и с подъёмом (hoisting). Может приводить к ошибкам при использовании в циклах и замыканиях.",
    "aliases": []
  },

  "let": {
    "title": "let",
    "description": "Ключевое слово для объявления переменных с блочной областью видимости. Создаёт новую переменную для каждой итерации цикла.",
    "aliases": []
  },

  "const": {
    "title": "const",
    "description": "Ключевое слово для объявления констант с блочной областью видимости. Запрещает переназначение переменной, но не делает значение неизменяемым.",
    "aliases": []
  },

  "утечка памяти": {
    "title": "Утечка памяти",
    "description": "Ситуация, при которой данные продолжают удерживаться в памяти, хотя больше не нужны. Замыкания могут быть причиной утечек, если сохраняют ссылки на большие объекты.",
    "aliases": ["memory leak"]
  },

  "мемоизация": {
    "title": "Мемоизация",
    "description": "Техника оптимизации, при которой результаты выполнения функции сохраняются и переиспользуются при повторных вызовах с теми же аргументами.",
    "aliases": ["memoization"]
  },

  "event loop": {
    "title": "Event Loop",
    "description": "Механизм, который управляет выполнением JavaScript и обработкой событий: выполняет синхронный код из стека, затем микрозадачи, затем берёт одну макрозадачу, и цикл повторяется.",
    "aliases": ["эвент луп"]
  },

  "стек вызовов": {
    "title": "Стек вызовов (Call Stack)",
    "description": "Структура, в которой выполняется синхронный JavaScript-код: текущая функция находится наверху стека. Пока стек не пуст, никакие очереди задач не выполняются.",
    "aliases": ["call stack"]
  },

  "микрозадача": {
    "title": "Микрозадача",
    "description": "Задача с повышенным приоритетом, которая выполняется после завершения текущего синхронного стека и перед следующей макрозадачей. Источники: Promise.then/catch/finally, queueMicrotask (и часто MutationObserver).",
    "aliases": ["microtask"]
  },

  "очередь микрозадач": {
    "title": "Очередь микрозадач (Microtask Queue)",
    "description": "Очередь, в которую попадают микрозадачи. Перед выполнением следующей макрозадачи движок старается вычистить микрозадачи полностью.",
    "aliases": ["microtask queue"]
  },

  "макрозадача": {
    "title": "Макрозадача",
    "description": "Обычная задача (task), которую Event Loop берёт из очереди по одной за тик. Примеры: setTimeout, setInterval, обработчики событий UI, I/O.",
    "aliases": ["task", "macrotask"]
  },

  "очередь задач": {
    "title": "Очередь задач (Task Queue)",
    "description": "Очередь, в которую попадают макрозадачи (task/macrotask). Event Loop обычно выполняет одну задачу из этой очереди за цикл (tick), затем снова проверяет микрозадачи.",
    "aliases": ["task queue", "macrotask queue"]
  },

  "web apis": {
    "title": "Web APIs",
    "description": "API окружения браузера (не часть JS-движка): таймеры, DOM-события, сетевые операции, рендеринг и др. Результаты работы Web APIs ставят колбэки в очереди задач.",
    "aliases": ["webapi", "окружение браузера"]
  },

  "queuemicrotask": {
    "title": "queueMicrotask",
    "description": "Функция, которая добавляет колбэк в очередь микрозадач. Выполнится после текущего синхронного кода и до следующей макрозадачи.",
    "aliases": []
  },

  "settimeout": {
    "title": "setTimeout",
    "description": "Функция таймера, которая планирует выполнение колбэка как макрозадачу (task). setTimeout(..., 0) не выполняется «сразу» — он выполнится после синхронного кода и всех микрозадач.",
    "aliases": ["таймер"]
  },

  "requestanimationframe": {
    "title": "requestAnimationFrame",
    "description": "API браузера для планирования выполнения колбэка перед отрисовкой следующего кадра. Используется для плавных анимаций и синхронизации с рендерингом.",
    "aliases": ["raf"]
  },

  "голодание очереди": {
    "title": "Голодание очереди (Starvation)",
    "description": "Ситуация, когда задачи из очереди макрозадач долго не выполняются из-за бесконечного потока микрозадач. Приводит к лагам и «зависанию» таймеров/событий.",
    "aliases": ["starvation"]
  },

  "promise": {
    "title": "Promise",
    "description": "Объект-обёртка над асинхронным результатом. Может быть в состоянии ожидания (pending), успеха (fulfilled) или ошибки (rejected). Колбэки then/catch/finally выполняются асинхронно как микрозадачи.",
    "aliases": []
  },
  "pending": {
    "title": "Promise: pending",
    "description": "Состояние Promise «в ожидании»: операция ещё не завершилась, результата или ошибки нет.",
    "aliases": []
  },
  "fulfilled": {
    "title": "Promise: fulfilled",
    "description": "Состояние Promise «успех»: операция завершилась успешно, есть значение результата.",
    "aliases": ["resolved"]
  },
  "rejected": {
    "title": "Promise: rejected",
    "description": "Состояние Promise «ошибка»: операция завершилась с ошибкой, есть причина (reason).",
    "aliases": []
  },
  "then": {
    "title": "then",
    "description": "Метод Promise для обработки успешного результата (и опционально ошибки). Всегда возвращает новый Promise и планирует обработчик как микрозадачу.",
    "aliases": []
  },
  "catch": {
    "title": "catch",
    "description": "Метод Promise для обработки ошибки. Эквивалентен then(null, onRejected). Возвращает новый Promise.",
    "aliases": []
  },
  "finally": {
    "title": "finally",
    "description": "Метод Promise, который выполняется при любом исходе (успех/ошибка) и обычно используется для очистки (например, скрыть loader). Не предназначен для трансформации результата.",
    "aliases": []
  },
  "promise.all": {
    "title": "Promise.all",
    "description": "Ждёт завершения всех Promise. Если хотя бы один отклонён (rejected) — весь результат будет rejected.",
    "aliases": []
  },
  "promise.allsettled": {
    "title": "Promise.allSettled",
    "description": "Ждёт завершения всех Promise и возвращает массив статусов каждого (fulfilled/rejected). Не падает из-за ошибок.",
    "aliases": []
  },
  "promise.race": {
    "title": "Promise.race",
    "description": "Возвращает результат первого завершившегося Promise (успех или ошибка).",
    "aliases": []
  },
  "promise.any": {
    "title": "Promise.any",
    "description": "Возвращает первый успешно завершившийся Promise. Если все упали — бросает AggregateError.",
    "aliases": []
  },
  "aggregateerror": {
    "title": "AggregateError",
    "description": "Тип ошибки, который используется, например, в Promise.any, когда все промисы завершились с ошибкой. Содержит набор причин.",
    "aliases": []
  },
  "async": {
    "title": "async",
    "description": "Ключевое слово, которое делает функцию асинхронной. Такая функция всегда возвращает Promise, даже если явно возвращается обычное значение.",
    "aliases": []
  },
  "await": {
    "title": "await",
    "description": "Оператор, который приостанавливает выполнение async-функции до завершения Promise. При rejected Promise выбрасывает ошибку.",
    "aliases": []
  },
  "unhandledpromiserejection": {
    "title": "UnhandledPromiseRejection",
    "description": "Ошибка, возникающая, когда Promise был отклонён (rejected), но ошибка не была обработана через catch или try/catch.",
    "aliases": []
  },
  

  "this": {
    "title": "this",
    "description": "Контекст выполнения функции в JavaScript. Определяется в момент вызова функции и зависит от способа вызова, а не от места объявления.",
    "aliases": []
  },
  "context": {
    "title": "Контекст выполнения",
    "description": "Объект, на который указывает this при выполнении функции.",
    "aliases": []
  },
  "bind": {
    "title": "bind",
    "description": "Метод функции, который возвращает новую функцию с жёстко привязанным this и, при необходимости, аргументами.",
    "aliases": []
  },
  "call": {
    "title": "call",
    "description": "Метод функции, который вызывает её немедленно с указанным this и аргументами, переданными через запятую.",
    "aliases": []
  },
  "apply": {
    "title": "apply",
    "description": "Метод функции, аналогичный call, но принимающий аргументы в виде массива.",
    "aliases": []
  },
  "arrow-function": {
    "title": "Arrow Function",
    "description": "Стрелочная функция в JavaScript, не имеющая собственного this и использующая this из внешней лексической области.",
    "aliases": ["arrow"]
  },

  "прототип": {
    "title": "Прототип",
    "description": "Объект, на который другой объект ссылается при поиске свойств и методов. Используется в механизме прототипного наследования.",
    "aliases": []
  },
  "[[prototype]]": {
    "title": "[[Prototype]]",
    "description": "Внутренний слот объекта (скрытая ссылка), который указывает на его прототип. По этой цепочке JS ищет свойства, если их нет на самом объекте.",
    "aliases": []
  },
  "прототипная цепочка": {
    "title": "Прототипная цепочка",
    "description": "Последовательность объектов, по которой движок JS ищет свойство: объект → его [[Prototype]] → [[Prototype]] прототипа → ... → null.",
    "aliases": []
  },
  "__proto__": {
    "title": "__proto__",
    "description": "Исторический геттер/сеттер для доступа к [[Prototype]]. Знать нужно, но в современном коде лучше использовать Object.getPrototypeOf / Object.setPrototypeOf.",
    "aliases": []
  },
  "prototype": {
    "title": "prototype",
    "description": "Свойство функции-конструктора. Именно оно становится [[Prototype]] у объектов, созданных через new этой функции.",
    "aliases": []
  },
  "конструктор": {
    "title": "Функция-конструктор",
    "description": "Функция, которая вызывается с new для создания объекта. Внутри неё this указывает на создаваемый объект.",
    "aliases": []
  },
  "new": {
    "title": "new",
    "description": "Оператор создания объекта: создаёт новый объект, связывает его [[Prototype]] с prototype конструктора, вызывает конструктор с this и возвращает объект (если конструктор не вернул объект явно).",
    "aliases": []
  },
  "object.create": {
    "title": "Object.create",
    "description": "Метод, который создаёт новый объект с указанным прототипом: Object.create(proto) делает так, что [[Prototype]] нового объекта указывает на proto.",
    "aliases": []
  },
  "instanceof": {
    "title": "instanceof",
    "description": "Оператор, который проверяет наличие prototype конструктора в прототипной цепочке объекта.",
    "aliases": []
  },
  "перекрытие свойств": {
    "title": "Перекрытие свойств (Shadowing)",
    "description": "Ситуация, когда свойство есть и на объекте, и в его прототипе. При обращении побеждает ближайшее — собственное свойство объекта.",
    "aliases": ["shadowing"]
  },

  "mutating методы": {
    "title": "Mutating методы массива",
    "description": "Методы массива, которые изменяют исходный массив. Использование может приводить к побочным эффектам и багам в state/UI.",
    "aliases": ["mutating methods"]
  },
  "non-mutating методы": {
    "title": "Non-mutating методы массива",
    "description": "Методы массива, которые не изменяют исходный массив, а возвращают новый массив или значение. Предпочтительны в современном фронтенде.",
    "aliases": ["non-mutating methods"]
  },
  "map": {
    "title": "Array.map",
    "description": "Метод массива для трансформации элементов. Возвращает новый массив той же длины.",
    "aliases": []
  },
  "filter": {
    "title": "Array.filter",
    "description": "Метод массива для фильтрации элементов по условию. Возвращает новый массив.",
    "aliases": []
  },
  "reduce": {
    "title": "Array.reduce",
    "description": "Метод массива, который сводит массив к одному значению с помощью аккумулятора и функции-редьюсера.",
    "aliases": []
  },
  "аккумулятор": {
    "title": "Аккумулятор (Accumulator)",
    "description": "Промежуточное значение в reduce, которое накапливает результат вычислений при обходе массива.",
    "aliases": ["acc"]
  },
  "initialvalue": {
    "title": "Initial Value",
    "description": "Начальное значение аккумулятора в reduce. Определяет тип результирующего значения и предотвращает ошибки на пустых массивах.",
    "aliases": ["initial value"]
  },

  "shallow copy": {
    "title": "Shallow copy (поверхностная копия)",
    "description": "Копирование, при котором копируются только значения первого уровня, а вложенные объекты остаются общими по ссылке.",
    "aliases": ["поверхностное копирование"]
  },
  "deep copy": {
    "title": "Deep copy (глубокая копия)",
    "description": "Копирование, при котором рекурсивно создаются новые копии всех вложенных объектов, без общих ссылок.",
    "aliases": ["глубокое копирование"]
  },
  "object.assign": {
    "title": "Object.assign",
    "description": "Метод для поверхностного копирования свойств одного или нескольких объектов в целевой объект.",
    "aliases": []
  },
  "spread оператор": {
    "title": "Spread оператор",
    "description": "Синтаксис `...`, используемый для поверхностного копирования объектов и массивов.",
    "aliases": ["spread"]
  },
  "structuredclone": {
    "title": "structuredClone",
    "description": "Нативный API для глубокого клонирования объектов, поддерживающий Date, Map, Set и циклические ссылки.",
    "aliases": []
  },

  "set": {
    "title": "Set",
    "description": "Коллекция уникальных значений без дубликатов. Поддерживает быстрые операции add, has и delete.",
    "aliases": []
  },
  "weakmap": {
    "title": "WeakMap",
    "description": "Коллекция ключ–значение, где ключами могут быть только объекты. Не удерживает объекты в памяти и позволяет сборщику мусора их очищать.",
    "aliases": []
  },
  "weakset": {
    "title": "WeakSet",
    "description": "Коллекция объектов, не удерживающая их в памяти. Используется для пометок и флагов.",
    "aliases": []
  },
  "дедупликация": {
    "title": "Дедупликация",
    "description": "Процесс удаления дубликатов значений из коллекции, часто реализуемый с помощью Set.",
    "aliases": []
  },
 
  "abortcontroller": {
    "title": "AbortController",
    "description": "API для отмены асинхронных операций (чаще всего fetch). Позволяет явно сигнализировать, что операция больше не нужна.",
    "aliases": []
  },
  "abortsignal": {
    "title": "AbortSignal",
    "description": "Объект-сигнал, связанный с AbortController. Передаётся в асинхронные операции и уведомляет их об отмене.",
    "aliases": []
  },
  "aborterror": {
    "title": "AbortError",
    "description": "Специальная ошибка, которая возникает при отмене асинхронной операции через AbortController. Является ожидаемым поведением.",
    "aliases": []
  },
  "race condition": {
    "title": "Race condition",
    "description": "Ситуация, когда несколько асинхронных операций конкурируют за обновление состояния, и результат зависит от порядка их завершения.",
    "aliases": ["гонка состояний"]
  },

  "intersectionobserver": {
    "title": "IntersectionObserver",
    "description": "Browser API для отслеживания пересечения элемента с viewport или контейнером. Часто используется для lazy-loading и анимаций при появлении.",
    "aliases": []
  },
  "resizeobserver": {
    "title": "ResizeObserver",
    "description": "Browser API для отслеживания изменений размеров элемента. Полезен для адаптивных интерфейсов и графиков.",
    "aliases": []
  },
  "mutationobserver": {
    "title": "MutationObserver",
    "description": "Browser API для отслеживания изменений DOM: добавление/удаление нод, изменение атрибутов и текста.",
    "aliases": []
  },
  "intersectionratio": {
    "title": "intersectionRatio",
    "description": "Значение от 0 до 1, показывающее, какая часть элемента находится в зоне наблюдения IntersectionObserver.",
    "aliases": []
  },
  
  "requestidlecallback": {
    "title": "requestIdleCallback",
    "description": "Browser API для выполнения фоновых задач в свободное (idle) время браузера. Не подходит для критичной UI-логики.",
    "aliases": ["rIC"]
  },
  "idle time": {
    "title": "Idle time",
    "description": "Периоды, когда браузер не занят рендерингом и обработкой пользовательских событий и может выполнять фоновые задачи.",
    "aliases": []
  },
  "repaint": {
    "title": "Repaint",
    "description": "Этап рендеринга браузера, на котором происходит перерисовка визуального представления элементов.",
    "aliases": []
  },

  "рекурсия": {
    "title": "Рекурсия",
    "description": "Техника программирования, при которой функция вызывает саму себя для решения подзадач до достижения базового случая.",
    "aliases": []
  },
  "базовый случай": {
    "title": "Базовый случай",
    "description": "Условие завершения рекурсии. Предотвращает бесконечные вызовы и переполнение стека.",
    "aliases": []
  },
  "call stack": {
    "title": "Call Stack",
    "description": "Стек вызовов функций, в котором хранятся контексты выполнения активных функций.",
    "aliases": ["стек вызовов"]
  },
  "stack overflow": {
    "title": "Stack Overflow",
    "description": "Ошибка переполнения стека вызовов, возникающая при слишком глубокой или бесконечной рекурсии.",
    "aliases": []
  },
  "tail recursion": {
    "title": "Хвостовая рекурсия",
    "description": "Форма рекурсии, при которой рекурсивный вызов является последней операцией функции. В JavaScript не имеет гарантированной оптимизации.",
    "aliases": []
  },

  "каррирование": {
    "title": "Каррирование (Currying)",
    "description": "Техника функционального программирования, при которой функция с несколькими аргументами преобразуется в цепочку функций, каждая из которых принимает один аргумент.",
    "aliases": ["currying"]
  },
  "частичное применение": {
    "title": "Частичное применение (Partial Application)",
    "description": "Техника, при которой функция вызывается с частью аргументов и возвращает новую функцию, ожидающую оставшиеся аргументы.",
    "aliases": ["partial application"]
  },
  "функция высшего порядка": {
    "title": "Функция высшего порядка",
    "description": "Функция, которая принимает другие функции как аргументы или возвращает функцию в качестве результата.",
    "aliases": []
  },
  
  "rendering pipeline": {
    "title": "Rendering Pipeline",
    "description": "Последовательность этапов, через которые браузер проходит для отображения страницы: DOM → CSSOM → Render Tree → Layout → Paint → Compositing.",
    "aliases": []
  },
  "dom": {
    "title": "DOM",
    "description": "Document Object Model — древовидное представление HTML-документа, с которым работает JavaScript.",
    "aliases": []
  },
  "cssom": {
    "title": "CSSOM",
    "description": "CSS Object Model — объектная модель стилей, используемая браузером при построении Render Tree.",
    "aliases": []
  },
  "render tree": {
    "title": "Render Tree",
    "description": "Дерево визуальных элементов, построенное на основе DOM и CSSOM. Используется для layout и paint.",
    "aliases": []
  },
  "layout": {
    "title": "Layout (Reflow)",
    "description": "Этап рендеринга, на котором браузер вычисляет размеры и положение элементов на странице.",
    "aliases": ["reflow"]
  },
  "paint": {
    "title": "Paint",
    "description": "Этап рендеринга, на котором браузер рисует пиксели: цвета, текст, границы, тени.",
    "aliases": []
  },
  "compositing": {
    "title": "Compositing",
    "description": "Финальный этап рендеринга, на котором слои собираются и отображаются с помощью GPU.",
    "aliases": []
  },

  "reflow": {
  "title": "Reflow (Layout)",
  "description": "Этап рендеринга, при котором браузер пересчитывает размеры и положение элементов. Самый дорогой по производительности.",
  "aliases": ["layout"]
  },

  "composite": {
    "title": "Composite",
    "description": "Этап рендеринга, на котором браузер собирает слои и применяет transform/opacity с использованием GPU.",
    "aliases": ["compositing"]
  },
  "layout thrashing": {
    "title": "Layout Thrashing",
    "description": "Антипаттерн, при котором происходит частое чередование чтения и записи layout-свойств, вызывая множественные reflow.",
    "aliases": []
  },
  "gpu acceleration": {
    "title": "GPU Acceleration",
    "description": "Использование графического процессора для ускорения рендеринга, особенно на этапе compositing.",
    "aliases": []
  },

 "critical rendering path": {
  "title": "Critical Rendering Path",
  "description": "Последовательность шагов, которые браузер выполняет от получения HTML до первого отображения контента: DOM → CSSOM → Render Tree → Layout → Paint.",
  "aliases": ["CRP"]
},
"blocking resource": {
  "title": "Блокирующий ресурс",
  "description": "Ресурс (CSS или JS), который останавливает построение страницы и задерживает первый рендер.",
  "aliases": []
},
"defer": {
  "title": "defer",
  "description": "Атрибут script, при котором JavaScript загружается параллельно HTML и выполняется после завершения парсинга документа.",
  "aliases": []
},

"critical css": {
  "title": "Critical CSS",
  "description": "Минимальный набор CSS-стилей, необходимый для отображения контента в области первого экрана (above-the-fold).",
  "aliases": []
},
"preload": {
  "title": "preload",
  "description": "HTML-механизм для приоритетной загрузки критически важных ресурсов (шрифты, стили, скрипты).",
  "aliases": []
},
"preconnect": {
  "title": "preconnect",
  "description": "Механизм, позволяющий заранее установить сетевое соединение с внешним источником для ускорения загрузки ресурсов.",
  "aliases": []
},

"fcp": {
  "title": "FCP (First Contentful Paint)",
  "description": "Момент времени, когда браузер впервые отрисовал любой контент на странице (текст, изображение, svg).",
  "aliases": []
},
"lcp": {
  "title": "LCP (Largest Contentful Paint)",
  "description": "Момент, когда был отрисован самый крупный видимый элемент страницы. Главная метрика скорости загрузки.",
  "aliases": []
},
"cls": {
  "title": "CLS (Cumulative Layout Shift)",
  "description": "Метрика визуальной стабильности, показывающая, насколько сильно элементы страницы смещаются во время загрузки.",
  "aliases": []
},
"tti": {
  "title": "TTI (Time To Interactive)",
  "description": "Время, когда страница становится полностью интерактивной. Считается устаревшей метрикой.",
  "aliases": []
},
"core web vitals": {
  "title": "Core Web Vitals",
  "description": "Набор ключевых метрик UX от Google, включающий LCP, CLS и INP.",
  "aliases": []
},
"inp": {
  "title": "INP (Interaction to Next Paint)",
  "description": "Метрика отзывчивости интерфейса, показывающая задержку между пользовательским действием и следующей отрисовкой.",
  "aliases": []
},

"devtools": {
  "title": "Chrome DevTools",
  "description": "Набор инструментов браузера для отладки, анализа производительности, сети, рендеринга и JavaScript.",
  "aliases": []
},
"performance tab": {
  "title": "Performance (DevTools)",
  "description": "Вкладка DevTools для записи и анализа работы main thread, рендеринга, layout, paint и long tasks.",
  "aliases": []
},
"long task": {
  "title": "Long Task",
  "description": "Задача, блокирующая main thread более чем на 50мс и ухудшающая отзывчивость интерфейса.",
  "aliases": []
},
"lighthouse": {
  "title": "Lighthouse",
  "description": "Инструмент автоматического аудита сайта по показателям производительности, доступности, SEO и best practices.",
  "aliases": []
},
"ttfb": {
  "title": "TTFB (Time To First Byte)",
  "description": "Время от отправки запроса до получения первого байта ответа от сервера.",
  "aliases": []
},

"event propagation": {
  "title": "Event Propagation",
  "description": "Механизм распространения DOM-событий через фазы capturing, target и bubbling.",
  "aliases": []
},
"capturing": {
  "title": "Capturing phase",
  "description": "Фаза события, при которой оно распространяется сверху вниз по DOM-дереву (от window к target).",
  "aliases": ["погружение"]
},
"bubbling": {
  "title": "Bubbling phase",
  "description": "Фаза события, при которой оно всплывает снизу вверх по DOM-дереву (от target к window).",
  "aliases": ["всплытие"]
},
"event delegation": {
  "title": "Event Delegation",
  "description": "Техника обработки событий, при которой один обработчик на родителе обрабатывает события от дочерних элементов.",
  "aliases": ["делегирование событий"]
},
"event.target": {
  "title": "event.target",
  "description": "Элемент, на котором событие произошло фактически.",
  "aliases": []
},
"event.currenttarget": {
  "title": "event.currentTarget",
  "description": "Элемент, на котором зарегистрирован обработчик события.",
  "aliases": []
},
"stoppropagation": {
  "title": "stopPropagation",
  "description": "Метод события, останавливающий дальнейшее распространение события по DOM.",
  "aliases": []
},
"preventdefault": {
  "title": "preventDefault",
  "description": "Метод события, отменяющий стандартное поведение браузера, не влияя на распространение события.",
  "aliases": []
}


}