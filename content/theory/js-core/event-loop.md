# Event Loop в JavaScript

## Зачем это нужно

Event Loop — это то, что объясняет **порядок выполнения кода** в браузере и Node.js. Без него невозможно уверенно:
- дебажить асинхронные баги ("почему лог не там?" / "почему стейт не успел обновиться?")
- понимать `Promise`, `async/await`, `setTimeout`, обработчики событий
- объяснять *hydration mismatch* и мерцания в SSR (часто косвенно связано с таймингами)
- оптимизировать UI (когда использовать `requestAnimationFrame`, как избежать лагов)

На собеседованиях Event Loop — базовая проверка на middle: **понимаешь ли ты, что такое синхронный стек, очереди задач и микрозадачи**.

---

## Краткое определение

**Event Loop** — это механизм, который управляет выполнением JavaScript-кода и обработкой событий, координируя:
- **стек вызовов** (синхронный код),
- **Web APIs / окружение** (таймеры, сетевые события, DOM),
- **очереди задач** (что выполнить после текущего стека).

Ключевая идея:
> Сначала выполняется весь синхронный код, затем — микрозадачи, затем — одна макрозадача, и цикл повторяется.

---

## Как это работает (модель в голове)

Представь 4 основных сущности:

1) **Call Stack (стек вызовов)**  
   Здесь выполняется синхронный JavaScript-код.

2) **Web APIs (окружение браузера / Node)**  
   Здесь живут таймеры, сетевые операции, события, рендеринг и т.д.

3) **Microtask Queue (очередь микрозадач)**  
   Сюда попадают: `Promise.then/catch/finally`, `queueMicrotask`, (часто) `MutationObserver`.

4) **Task Queue / Macrotask Queue (очередь макрозадач)**  
   Сюда попадают: `setTimeout`, `setInterval`, события UI, I/O и т.д.

### Упрощённый алгоритм цикла

1. Выполнить **весь синхронный код** из стека вызовов до конца.
2. Выполнить **все микрозадачи** (и микрозадачи, добавленные микрозадачами — тоже).
3. Взять **одну** макрозадачу из очереди и выполнить её.
4. Вернуться к шагу 2 (перед следующей макрозадачей снова вычищаются микрозадачи).
5. Параллельно браузер старается вклинить **рендеринг** (layout/paint/composite) между тасками, когда может.

Важно: детали отличаются между средами и браузерами, но **правило “microtasks before next task”** — ядро.

---

## Ключевые детали и нюансы

### 1) Микрозадачи «приоритетнее» макрозадач
Если микрозадач много, они могут задержать выполнение таймеров и обработчиков событий.

### 2) `async/await` — это синтаксический сахар над Promise
`await` *планирует продолжение функции как микрозадачу*.

### 3) `setTimeout(fn, 0)` — не “сразу”
Он ставит задачу в очередь макрозадач. Она выполнится **после** текущего стека и **после** всех микрозадач.

### 4) Рендеринг UI
Браузер обычно рендерит кадры около 60 FPS. Чтобы анимации были плавными, работу с DOM полезно планировать через `requestAnimationFrame`.

---

## Типовые ловушки (любят на собеседованиях)

### Ловушка 1 — `Promise` раньше `setTimeout`
```js
console.log(1);

setTimeout(() => console.log(2), 0);

Promise.resolve().then(() => console.log(3));

console.log(4);
```
Ожидаемый порядок:
1, 4, 3, 2

Почему:
- 1 и 4 — синхронно
- 3 — микрозадача
- 2 — макрозадача

---

### Ловушка 2 — микрозадачи могут «заблокировать» таймеры (starvation)
```js
function spinMicrotasks() {
  Promise.resolve().then(spinMicrotasks);
}

setTimeout(() => console.log("timer"), 0);
spinMicrotasks();
```
`timer` может **не выполниться долго**: микрозадачи бесконечно забирают очередь.

---

### Ловушка 3 — `await` меняет порядок
```js
async function f() {
  console.log("A");
  await null;
  console.log("B");
}

console.log("1");
f();
console.log("2");
```
Порядок:
1, A, 2, B

Почему: продолжение после `await` — микрозадача.

---

## Примеры кода (от простого к tricky)

### Пример 1 — базовый порядок
```js
console.log("sync");

queueMicrotask(() => console.log("micro"));

setTimeout(() => console.log("macro"), 0);

console.log("end");
```
Обычно: `sync`, `end`, `micro`, `macro`

---

### Пример 2 — цепочка микрозадач
```js
Promise.resolve()
  .then(() => console.log("m1"))
  .then(() => console.log("m2"));

setTimeout(() => console.log("t1"), 0);
```
Обычно: `m1`, `m2`, `t1` (после завершения синхронного кода)

---

### Пример 3 — `requestAnimationFrame` и рендер
```js
console.log("start");

requestAnimationFrame(() => {
  console.log("raf");
});

setTimeout(() => console.log("timeout"), 0);

Promise.resolve().then(() => console.log("micro"));

console.log("end");
```
Обычно:
- `start`, `end` (sync)
- `micro` (microtask)
- затем браузер может вставить рендер-кадр и выполнить `raf`
- `timeout` (task)

Точный порядок `raf` vs `timeout` зависит от браузера и нагрузки, но `micro` почти всегда раньше следующей задачи.

---

## Как отвечать на собеседовании

Нормальный middle-ответ (структура):

1) Дай определение: **стек + очереди + цикл**
2) Назови очереди: **microtask queue** и **task/macrotask queue**
3) Скажи правило: **sync → all microtasks → one macrotask**
4) Приведи короткий пример: `Promise.then` раньше `setTimeout`
5) Добавь нюанс: микрозадачи могут вызвать starvation, `await` — микрозадача

---

## Вопросы для самопроверки

1. Почему `Promise.then` выполняется раньше `setTimeout(..., 0)`?
2. Что такое микрозадача и как её создать?
3. Что такое макрозадача и как её создать?
4. Почему `await` меняет порядок логов?
5. Что такое starvation (голодание очереди) и почему это плохо?

---

## Связанные темы

- Promises и методы Promise
- async/await
- AbortController и отмена запросов
- requestAnimationFrame / requestIdleCallback
- Performance / long tasks
