# Области видимости и замыкания в JavaScript

## Зачем это нужно

Области видимости и замыкания — фундаментальные концепции JavaScript, без понимания которых невозможно уверенно писать код уровня Middle.

Эта тема напрямую влияет на:
- работу с асинхронностью (callbacks, promises, async/await)
- обработчики событий
- хуки в React (useEffect, useCallback, useMemo)
- composables во Vue
- понимание поведения переменных во времени

На собеседованиях замыкания проверяют не знание синтаксиса, а **понимание того, как JavaScript исполняет код и управляет памятью**.

---

## Краткое определение

**Область видимости (scope)** — это область программы, в которой переменная доступна для использования.

**Замыкание (closure)** — это функция, которая имеет доступ к переменным из своей внешней (лексической) области видимости даже после того, как внешняя функция завершила выполнение.

Ключевая идея:
> Функции в JavaScript “помнят” контекст, в котором они были созданы.

---

## Как это работает (модель в голове)

### Лексическая область видимости

JavaScript использует **лексическую (статическую) область видимости**.

Это означает:
- область видимости определяется **в момент объявления функции**
- а не в момент её вызова

Пример:

```js
function outer() {
  const a = 10;

  function inner() {
    console.log(a);
  }

  return inner;
}

const fn = outer();
fn(); // 10
```

Что происходит пошагово:
1. Вызывается `outer`, создаётся переменная `a`
2. Функция `inner` создаётся внутри `outer` и “видит” `a`
3. `outer` завершает выполнение
4. `inner` всё ещё имеет доступ к `a`

Это и есть **замыкание**.

---

## Типы областей видимости

### 1. Глобальная область видимости

Переменные, объявленные вне функций.

```js
const globalValue = 42;
```

❗ Использовать осторожно — высокий риск конфликтов и побочных эффектов.

---

### 2. Функциональная область видимости

Переменные, объявленные внутри функции, доступны только внутри неё.

```js
function test() {
  const x = 5;
}
```

---

### 3. Блочная область видимости (`let`, `const`)

Переменные доступны только внутри блока `{}`.

```js
if (true) {
  let a = 1;
  const b = 2;
}
// a и b недоступны
```

`var` блочной области видимости **не имеет**.

---

## Ключевые детали и нюансы

### Замыкание хранит ссылку, а не значение

```js
function counter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const c = counter();
c(); // 1
c(); // 2
```

Важно:
- `count` **не копируется**
- функция хранит **ссылку** на переменную
- значение живёт, пока есть хотя бы одно замыкание

---

### Замыкание и цикл — классическая ловушка

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
}
// 3, 3, 3
```

Почему:
- `var` создаёт **одну общую переменную**
- все колбэки замыкаются на одну и ту же ссылку

Исправление:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
}
// 0, 1, 2
```

`let` создаёт **новую переменную на каждую итерацию**.

---

## Типовые ловушки (часто на собеседованиях)

### Утечки памяти

Замыкания могут удерживать данные дольше, чем нужно.

```js
function heavy() {
  const bigData = new Array(1_000_000);
  return () => console.log(bigData.length);
}
```

Если замыкание живёт долго — `bigData` не будет очищена сборщиком мусора.

---

### Ошибочное ожидание “обновления значения”

```js
function createLogger(value) {
  return () => console.log(value);
}

const log = createLogger(5);
value = 10;
log(); // 5
```

Функция замкнулась на **аргумент**, а не на внешнюю переменную.

---

## Примеры реального использования

### 1. Счётчик

```js
function createCounter() {
  let count = 0;
  return () => ++count;
}
```

---

### 2. Мемоизация

```js
function memoize(fn) {
  const cache = {};
  return (arg) => {
    if (cache[arg]) return cache[arg];
    cache[arg] = fn(arg);
    return cache[arg];
  };
}
```

---

### 3. Модульный паттерн

```js
const userModule = (() => {
  let name = "Alex";

  return {
    getName: () => name,
    setName: (newName) => {
      name = newName;
    },
  };
})();
```

---

## Как отвечать на собеседовании

Структура хорошего ответа:
1. Что такое замыкание (кратко)
2. Лексическая область видимости
3. Замыкание хранит ссылки, а не значения
4. Пример (counter или цикл + let)
5. Где используется на практике
6. Упоминание возможных утечек памяти

---

## Вопросы для самопроверки

1. Что такое лексическая область видимости?
2. Почему `let` решает проблему замыкания в цикле?
3. В чём разница между `var`, `let` и `const`?
4. Почему замыкания могут приводить к утечкам памяти?
5. Где замыкания используются во фреймворках?

---

## Связанные темы

- Event Loop
- Асинхронность
- this / bind / call / apply
- React Hooks
- Vue Composables
